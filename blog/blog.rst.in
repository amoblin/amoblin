==================
|ArticleTitle|
==================

------------
for Docbones
------------

:作者: |AuthorOSSXP|_
:网址: http://www.ossxp.com/
:版本: |doc_rev|
:日期: |doc_date|
:版权信息: |Creative Commons|_

.. |date| date::        %Y-%m-%d %H:%M
.. |doc_rev| replace::  @ENV(DOC_REV)@
.. |doc_date| replace:: @ENV(DOC_DATE)@
.. |Creative Commons|   image:: images/cc-icon.png
.. _Creative Commons:   http://creativecommons.org/licenses/by-sa/3.0/
.. |AuthorOSSXP|        replace:: 北京群英汇信息技术有限公司
.. _AuthorOSSXP:        http://www.ossxp.com/
.. |ArticleTitle|       replace:: 群英汇博客 
.. _ArticleTitle:       http://www.ossxp.com/doc/

.. contents:: 目录
.. sectnum::

.. include:: DEFINES.txt
   :start-after: START_@ENV(DOC_BACKEND)@_HEADER_FOOTER
   :end-before: END_@ENV(DOC_BACKEND)@_HEADER_FOOTER

.. raw:: pdf

   Transition Dissolve 1
   PageBreak contentsPage


.. ############
.. ************
.. ============
.. ------------
.. ^^^^^^^^^^^^
.. """"""""""""

Vim 复制粘贴探秘
================

Vim作为最好用的文本编辑器之一，使用vim来编文档，写代码实在是很惬意的事情。每当学会了vim的一个新功能，就会很大地提高工作效率。有人使用vim几十年，还没有完全掌握vim的功能，这也说明了vim的强大。而这样何尝不是一件好事呢，只要有的学习，就有的提高。

最近使用Vim来写博客，发现在Vim中粘贴Python代码后，缩进就全乱了。仔细研究了以下，原来是自动缩进的缘故，于是做如下设置： ::

    :set noai nosi

取消了自动缩进和智能缩进，这样粘贴就不会错行了。但在有的vim中不行，还是排版错乱。

后来发现了更好用的设置： ::

    :set paste

进入paste模式以后，可以在插入模式下粘贴内容，不会有任何变形。这个真是灰常好用，情不自禁看了一下帮助，发现它做了这么多事：

- textwidth设置为0
- wrapmargin设置为0
- set noai
- set nosi
- softtabstop设置为0
- revins重置
- ruler重置
- showmatch重置
- formatoptions使用空值

下面的选项值不变，但却被禁用：

- lisp
- indentexpr
- cindent

怪不得之前只设置noai和nosi不行，原来与这么多因素有关！

但这样还是比较麻烦的，每次要粘贴的话，先set paste，然后粘贴，然后再set nopaste。有没有更方便的呢？你可能想到了，使用键盘映射呀，对。我们可以这样设置：::

    :map <F10> :set paste<CR>
    :map <F11> :set nopaste<CR>

这样在粘贴前按F10键启动paste模式，粘贴后按F11取消paste模式即可。其实，paste有一个切换paste开关的选项，这就是pastetoggle。通过它可以绑定快捷键来激活/取消 paste模式。比如：::
    
    :set pastetoggle=<F11>

这样减少了一个快捷键的占用，使用起来也更方便一些。

但，这是最方便的吗？Vimer们对高效的追求永无止境。还有其他更好地方法吗？

你可能想到了，vim寄存器。对，使用vim寄存器 "+p 粘贴即可。根本不用考虑是否自动缩进，是否paste模式，直接原文传递！::

    "+p

要说vim寄存器，就要从vim文件间的复制粘贴说起。

Vim中，若要复制当前行，普通模式下按 yy 即可，在要粘贴的地方按 p 。这是vim将复制内容保存到了自己的器存器中的缘故。如果在其他地方执行yy，新的内容将覆盖掉原寄存器中内容。如果想保存原寄存器中内容而同时增加新的内容呢？这时就要在yy前增加标签了。标签以双引号开始，跟着的是标签名称，可以是数字0-9，也可以是26个字母，然后就是复制操作，这样就把复制内容保存到该标签寄存器里。通过下面命令显示所有寄存器内容：::
    
    :reg

其中注意两个特殊的寄存器："* 和 "+。这两个寄存器是和系统相通的，前者关联系统选择缓冲区，后者关联系统剪切板。通过它们可以和其他程序进行数据交换。

备注：
    若寄存器列表里无"* 或 "+ 寄存器，则可能是由于没有安装vim的图形界面所致。Debian/Ubuntu下可以通过安装vim-gnome解决。 ::

    $ sudo apt-get install vim-gnome

选择缓冲区和系统剪切板啥子区别？让我们继续研究。

选择缓冲区和剪切板
------------------

不同于Windows，Linux系统里存在两个剪切板：一个叫做选择缓冲区(X11 selection buffer)，另一个才是剪切板(clipboard)。

选择缓冲区是实时的，当使用鼠标或键盘选择内容时，内容已经存在于选择缓冲区了，这或许就是选择缓冲区的由来吧。

使用下面的命令查看选择缓冲区的内容：::

    $ xclip -out

如果没有xclip命令，Debian/Ubuntu下可以通过如下命令安装：::

    $ sudo apt-get install xclip


可以使用鼠标中键或键入Shift+Insert来粘贴选择缓冲区的内容。但对于有些GUI程序，比如gedit，只能通过鼠标中键调用选择缓冲区的内容，使用Shift+Insert的话，调用的是剪切板的内容。


剪切板和Windows的剪切板类似，在选择文字内容后，执行Ctrl + c或在菜单里选择‘复制’的话，这时内容才存放到剪切板里。

使用下面的命令查看剪切板的内容：::

    $ xclip -out -sel clipboard

而使用剪切板的内容，则是Ctrl+v。 但在有些情况下，比如gnome-terminal，不能直接使用Ctrl+c，Ctrl+v，这时就要用Shift+Ctrl+c，Shift+Ctrl+v代替。

原格式粘贴
----------

好了，了解了选择缓冲区和剪切板，下面就是实现保留格式粘贴的完美解决方案：

* 方案一：

#. 选择文本内容
#. vim普通模式下按 "* p 将选择缓冲区中内容粘贴进来

* 方案二：

#. 复制文件内容
#. vim普通模式下按 "+ p 将剪切板内容粘贴进来

这时，如果要复制的内容也是vim编辑器中的内容，那么如何复制才更方便呢？

vim中的复制
-----------
vim有一个可视模式(Visual Mode)，在此模式下可以选择区域。可以在普通模式下键入v进入可视模式，也可以个性化一点，键入V进入行可视模式，或者键入Ctrl+v进入列可视模式。这时移动光标就可以选择内容了。注意这时被选内容已经实时保存于选择缓冲区了，当然你也可以键入"+y将此内容也保存到剪切板里，或者"ay将内容保存到标签为a的寄存器中。但要知道，只有前两个中的内容可以在其他程序中使用，而a寄存器中的内容只能在该vim编辑器内使用。

也可以通过鼠标来复制。这里首先要打开鼠标模式。::

    :set mouse=a

这样在普通模式下可以直接使用鼠标选择区域复制到选择缓冲区。但这种情况下不能复制到剪切板。

若要使用鼠标复制内容到剪切板，则需要做如下设置：::

    :set mouse=v

这种情况下，除了可以像上面一样直接使用鼠标选择区域复制到选择缓冲区以外，还可以在右键菜单中选择“复制”来保存到剪切板里。但新问题又出来了。若显示行号，也会将行号一并选择。你会想到，这好办呀，如果不需要行号的话，在复制前，先执行set nonu来取消行号显示呗。 

其实没必要这样，如果不需要复制行号的话，用在可视模式下用键盘来选择不就可以吗？

并且，从上面的讨论，我们不难得出，使用选择缓冲区比使用剪切板要方便的多，可以节省很多步骤。

所以，最终我们得到了vim文件间复制粘贴的完美方案，文件传输的中转使用选择缓冲区。

vim文件间复制粘贴完美方案
-------------------------

#. 在~/.vimrc中增加如下一行：::

    set mouse=a

#. 复制内容到选择缓冲区。

- 带行号时，使用鼠标选择内容区域。
- 不要行号，使用 "* yny 复制n行或可视模式下选择。

#. 将选择缓冲区中内容粘贴到vim文件。
    
- 插入模式下：Shift+Insert 或 鼠标中键
- 普通模式下： "* p

python egg学习笔记
=====================

经常接触Python的同学可能会注意到，当需要安装第三方python包时，可能会用到easy_install命令。easy_install是由PEAK(Python Enterprise Application Kit)开发的setuptools包里带的一个命令，它用来安装egg包。egg包是目前最流行的python应用打包部署方式。如何制作和安装egg包？下面我就简单的分析了一下。

安装setuptools
--------------

首先要安装setuptools工具。Debian/Ubuntu下可以直接使用apt安装：::

    $ sudo apt-get install python-setuptools

手工安装的话，有两种方式：

* 通过引导程序 `ez_setup.py <http://peak.telecommunity.com/dist/ez_setup.py>`_ 来安装。这个引导程序会联网下载最新版本setuptools来安装，同时也可以更新本地的setuptools。 ::

   $ wget http://peak.telecommunity.com/dist/ez_setup.py
   $ sudo python ez_setup.py

  更新setuptools：::

   $ sudo python ez_setup.py -U setuptools

* 或者下载setuptools的egg包来安装。可以在 `这里 <http://pypi.python.org/packages/2.6/s/setuptools/>`_ 查看最新版本下载。下载完毕以后通过sh安装。 ::

     $ wget http://pypi.python.org/packages/2.6/s/setuptools/setuptools-0.6c11-py2.6.egg
     $ sudo sh setuptools-0.6c11-py2.6.egg 
 
现在就可以使用easy_install命令来安装其他的egg包了。


制作自己的egg包
---------------

总是安装别人的egg包，是不是也想制作自己的egg包呢？好，接下来我们就自己制作一个简单的egg包。

首先建立工程目录egg-demo,初始化一个setup.py文件： ::

  $ mkdir egg-demo
  $ cd egg-demo
  $ touch setup.py
  $ ls
  setup.py

下面主要就是填充setup.py。setup.py其实是python工具包distutils的配置文件，setuptools就是基于distutils来做的。
在setup.py中通过setup函数来配置打包信息。首先要引入setuptools的函数setup。setuptools的setup其实就是distutils的setup函数，填写setup.py为以下内容： ::

    $ cat setup.py
    #!/usr/bin/env python
    #-*- coding:utf-8 -*-

    from setuptools import setup

    setup()

写到这里，一个空的egg配置文件就写好了。我们可以使用下面命令生成egg包： ::

    $ python setup.py bdist_egg

下面看看究竟生成了什么： ::

    $ ls -F
    build/ dist/ setup.py UNKNOWN.egg-info/

可以看到多了三个文件夹。而在dist文件夹下，有一个egg文件：UNKNOWN-0.0.0-py2.6.egg。

产蛋成功！先看看这个egg文件是什么格式的： ::

    $ file dist/UNKNOWN-0.0.0-py2.6.egg
    dist/UNKNOWN-0.0.0-py2.6.egg: Zip archive data, at least v2.0 to extract

噢，原来就是一个zip压缩包呀！好，再来看看内部构造： ::

    $ unzip -l dist/UNKNOWN-0.0.0-py2.6.egg
    Archive:  dist/KNOWN-0.0.0-py2.6.egg
      Length      Date    Time    Name
    ---------  ---------- -----   ----
          120  2010-12-06 17:04   EGG-INFO/SOURCES.txt
            1  2010-12-06 17:04   EGG-INFO/top_level.txt
            1  2010-12-06 17:04   EGG-INFO/zip-safe
            1  2010-12-06 17:04   EGG-INFO/dependency_links.txt
          227  2010-12-06 17:04   EGG-INFO/PKG-INFO
    ---------                     -------
          350                     5 files

只有一个EGG-INFO文件夹，内含五个egg信息文件，没了。

这个egg名称未知，版本0.0.0。这是因为我们在setup里什么也没有设置。

显然，这个egg什么也不能做。

下面给它加点料。

在setup.py中，setup函数接收一系列属性作为配置参数。

- name name是egg包的名称，也是寻找要打包的文件夹的名称，默认是UNKNOWN。
- version 版本号，默认0.0.0
- packages 这里要用到setuptools的另一个函数find_packages，顾名思义，find_packages用来将指定目录下的文件打包。
- zip_safe 默认是False，这样在每次生成egg包时都会检查项目文件的内容，确保无误。

还有一些描述性的属性，如description，long_description，author，author_email，license，keywords，platform，url等。

填充setup.py文件如下：::

    $ cat setup.py
    #!/usr/bin/env python
    #-*- coding:utf-8 -*-

    from setuptools import setup, find_packages

    setup(
            name = "demo",
            version="0.1.0",
            packages = find_packages(),
            zip_safe = False,

            description = "egg test demo.",
            long_description = "egg test demo, haha.",
            author = "amoblin",
            author_email = "amoblin@ossxp.com",

            license = "GPL",
            keywords = ("test", "egg"),
            platforms = "Independant",
            url = "",
            )

在egg-demo目录下建立和上述name名称相同的目录demo，demo目录下写__init__.py文件： ::

    $ mkdir demo
    $ cat demo/__init__.py
    #!/usr/bin/env python
    #-*- coding:utf-8 -*-

    def test():
        print "Hello, I'm amoblin."

    if __name__ == '__main__':
        test()

再次生成egg包以后查看egg包信息： ::

    $ python setup.py bdist_egg
    $ unzip -l dist/demo-0.1.0-py2.6.egg
    Archive:  dist/demo-0.1.0-py2.6.egg
      Length      Date    Time    Name
    ---------  ---------- -----   ----
          121  2010-12-06 17:30   demo/__init__.py
          344  2010-12-06 17:46   demo/__init__.pyc
          137  2010-12-06 17:46   EGG-INFO/SOURCES.txt
            5  2010-12-06 17:46   EGG-INFO/top_level.txt
            1  2010-12-06 17:46   EGG-INFO/zip-safe
            1  2010-12-06 17:46   EGG-INFO/dependency_links.txt
          227  2010-12-06 17:46   EGG-INFO/PKG-INFO
    ---------                     -------
          836                     7 files

可以看到，多了一个文件夹demo，里面有我们写的__init__.py。

奉行敏捷原则，先安装了体验一下再说： ::

    $ sudo python setup.py install
    running install
    install_dir /usr/local/lib/python2.6/dist-packages/
    ...
    creating /usr/local/lib/python2.6/dist-packages/demo-0.1.0-py2.6.egg
    Extracting demo-0.1.0-py2.6.egg to /usr/local/lib/python2.6/dist-packages
    demo 0.1.0 is already the active version in easy-install.pth

    Installed /usr/local/lib/python2.6/dist-packages/demo-0.1.0-py2.6.egg
    Processing dependencies for demo==0.1.0   
    Finished processing dependencies for demo==0.1.0

OK!安装完毕！接下来我们就可以直接通过import来使用啦！ ::

    $ python -c "from demo import test;test()"
    Hello, I'm amoblin.
    
成功输出！这说明安装正确。我们的一个egg包诞生了。

一般情况下，我们的源程序都放在src目录下，所以接下来将demo文件夹移动到src里。但这样也要修改setup.py文件，修改find_packages函数中参数为'src'，同时增加package_dir参数： ::

    packages=find_packages('src'),
    package_dir = {'':'src'}

这样告诉setuptools在src目录下找包，而不是原来默认的工程根目录。

egg文件卸载
------------

以python2.6版本为例，egg文件一般安装在/usr/local/lib/python2.6/dist-packages/目录下，该目录下还有一个easy-install.pth文件，用于存放安装的egg信息。::

    $ cd /usr/local/lib/python2.6/dist-packages
    $ cat easy-install.pth|grep demo
    ./demo-0.1.0-py2.6.egg
    $ ls -F|grep demo
    demo-0.1.0-py2.6.egg/

卸载egg文件很简单，首先将包含此egg的行从easy-install.pth中删除，然后删除egg文件夹即可。


绑定变量
========

当python脚本被调用的时候，会创建一组变量，这些变量用于在脚本里面访问其他的Zope对象和脚本，要查看和定义这些变量，可以到Binding标签视图里。其他Zope对象，像Perl脚本，DTML文档对象等，这些变量都无效。但ZPT里有相似的变量组。

一般情况下，这些变量的设置都不需要更改。下面介绍这些变量分别如何工作，以及如何在脚本中使用。

Context 默认绑定到context，指向调用本脚本的对象

Container 默认绑定到container，脚本定义处

Script 默认绑定到script，指向脚本自身

Namespace 默认留空。

如果使用ftp上传文件，那么就要在唉脚本的开头通过注释将上述内容列出，如下例：

::

## Script (Python) "example"
##bind container=container
##bind context=context
##bind namespace=
##bind script=script
##bind subpath=traverse_subpath
##parameters=name, age
##title=


其中的parameters列是脚本的参数。注意这些注释不仅仅是注释，它们包含语义信息。所以不能随便写，比如在bind前不能有空格，在parameters前也不能有空格等等。

如何使用呢？通过这些绑定，我们可以访问我们想要的对象。比如，通过context可以访问调用此脚本的对象。回到Zoo例子，下面这行：

::

 animail_id = context.getId()

就可以得到id值"hippo"，因为hoppo是这里的context，它的id是"hoppo"。我们可以通过这个方法访问任何对象的id，因为这个方法几乎存在于任何一个对象里。

使用Buildout管理项目
--------------------

本文讲解如何安装Plone到一个buildout，在一个扩展Plone的项目里工作时如何使用这个buildout。buildout是一个自包含的环境，在buildout里可以管理依赖（包含Zope，Plone和其他任何你需要的第三方产品或库）并且为项目自定义代码。即使不打算自定义代码，buildout也是很容易使得Plone的安装更健壮，更易测试。从Plone3.2开始，所有的实例都是基于buildout的。

在Plone 3.0版本以前，不使用图形界面安装的开发者和用户，大多数先设置一个Zope实例，然后把一些产品放置在Products目录下，就可以了。不幸的是，这样做有一些问题：

- 旧的无格式的Zope实例不能够很好的处理Python eggs包或者使用setuptools的名称空间包。但Plone3中的新包大多采用这些格式，并且越来越多的第三方包会使用这些格式。
- 除去访问eggs里封装的元数据，开发者会发现太浪费时间而不能把它打包，这样一旦脱离Zope环境就不能重用。
- 没有工具，在不同的环境里重复安装是很烦人的

eggs越来越重要，开发者应该选择合适的工具来管理代码。zc.buildout，以后可能只叫'buildout'，就是这样的工具。本文将讲述如何使用buildout来管理日常的开发。

Packages，products and eggs
---------------------------

