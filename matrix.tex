\documentclass[cjk]{beamer}
%\usetheme{Warsaw} 
\usepackage{CJKutf8}
\begin{document}
\begin{CJK*}{UTF8}{gbsn}
	\frame{
	\frametitle{数值分析}\pause
	$p_{k+1} = r_k + \beta_{k+1}p_k$ 2n flops\\
	注：CG至多n步即可计算$x^*$(在精确运算)可能“幸运中断”即$p_0=0$或$r_{k-1}=0$.\\
	$r_{k-1}=0\Leftrightarrow x_{k-1}=x^*$\\
	$p_k = 0 \Leftrightarrow p_k^TAp_k = 0$\\
	$r_{k-1}^Tr_{k-1}=r_{k-1}^T(r_{k-1}+\beta_kp_{k-1)}||r_{k-1}||^2 = r_{k-1}^Tp_k=0$\\
	$\Rightarrow r_{k-1}=0$\\
	计算量：对每个k，需要一个A乘向量+12n flops.设A为一个稠密阵，执行到n步，则需$2n^3+12n flops \approx 2n^3$对大的n。\\
	Cholesky分解:$A=LL^T,\frac{1}{3}n^3flops,CG=6$倍的Cholesky.\\
	如果A稀疏，即只有少量的非零元。常见的情况A只有O(n)个非零元。架设A每行的平均非零元为$n_\alpha(<<n)$此时Ax只需$2n_\alpha n flops.$所以执行n步的代价$2n_\alpha n^2+12n^2 flops << \frac{1}{3}n^3 for large n.$\\
	如果只进行k步，(k<<n,通常k<<n),则需$2n_\alpha kn + 12kn flops \le O(n^2) flops$\\
	}
	\frame{
	优点：\\
	\begin{itemize}
		\item 计算量小;
		\item 存储量：$x_k,r_k,p_k,Ap_k,$4个向量非常小;
		\item 不对A做任何变换，唯一的作用是形成和向量乘积，可能只需存储A的非零元;
		\item SOR,Jacobi, G-S,CG中不需估计任何参数。
	\end{itemize}
	定理2.2.3(收敛性结果) 令$A=A^T$正定，$\lambda_1$和$\lambda_n$为A的最大最小特征值，定义$k=\frac{\lambda_1}{\lambda_n}$，则$||x_k-x^*||_A \le 2(\frac{\sqrt{k}-1}{\sqrt{k}+1})^k||x_0-x^*||_A.$k为A的条件数。k越接近于1,CG收敛越快，比最速下降法快！当$k\gg1$时，CG可能收敛很慢。\\
	理论上算法很漂亮，但在有限精度下计算结果和理论论结果差别往往很大。计算出$r_j^Tr_j \neq O(\epsilon)$ 甚至近似线性相关。同样的问题对$p_k$也成立。$\Rightarrow $CG不稳定！$\Rightarrow$1952~1970方法被抛弃！\\
	1970:首先发现CG应该作为一种迭代法使用，即可对k<<n可能有$||x_k-x^*||$很小！\\
	结论：CG的不稳定性并不影响其收敛性！只是延误了收敛性。\\
	两者结合$\Rightarrow$ CG实用!\\
	}
	\frame{
	书31页，例n=5,得到一些结论。\\
	原理：要得到一个算法数值性质的一般结论，比如对CG，需对大量的实验，并且对大规模$n\gg1$。\\
	如果要找一个算法的缺点，则可对特定的问题实验，n大小不管。\\
	CG的一般性数值性质：\\
	A的中间特征值分布对CG的收敛速度影响巨大！\\
	典型的情形：$\lambda_1 \gg \lambda_2 \gg \cdots \gg \lambda_n$\\
	则经过几步后，CG的收敛因子将是$\frac{\sqrt{\frac{\lambda_2}{\lambda_{n-1}}-1}}{\sqrt{\frac{\lambda_2}{\lambda_{n-1}}}+1}$.而非$\frac{\sqrt{\frac{\lambda_1}{\lambda_n}-1}}{\sqrt{\frac{\lambda_1}{\lambda_n}}+1}$\\
	比如$\lambda_1=10^4,\lambda_n=1,\lambda_2=\cdots=\lambda_{n-1}=2$\\
	此时实际上只需k=3,即得$x-2=x^*2)$A的特征向量对CG的收敛性影响很大。如果b只由m个特征向量的组合生成，则CG的m步必然收敛$x_m=x^*$
	}
	\frame{
	\frametitle{预处理的CG法(PCG)}
	$||x_k-x^*||_A \le 2(\frac{\sqrt{k}-1}{\sqrt{k}+1})^k||x_0-x^*||_A$\\
	其中$k=\frac{\lambda_1}{\lambda_n}(\ge 1)$\\
	当k越接近于1,则CG可能收敛很快！\\
	当k$\gg$1,则CG可能收敛很慢！\\
	$\Rightarrow$ CG可能不实用。\\
	$\Rightarrow Ax=b\Leftrightarrow \hat{A}\hat{x}=\hat{b}$\\
	用k(A)和$k(\hat{A})$表示A和$\hat{A}$的条件数，若$k(\hat{A})\ll k(A),则对\hat{A}\hat{x}=\hat{b}$应用CG，则收敛一定很快。\\
	此称为预处理(条件)技术.(precondition)\\
	现状：
	\begin{itemize}
		\item 没有通用的有效的预处理技术
		\item 一般很难证明一种具体的预处理为何好
		\item 好的预处理技术+迭代法，可能产生非常有效的算法。\\
	\end{itemize}
	有三种形式：\\
	\begin{enumerate}
		\item 左预处理技术 $M^{-1}Ax=M^{-1}b$
		\item 右预处理技术 $AM^{-1}y=b,x=M^{-1}y$
		\item 分裂预处理技术 $M_1^{-1}AM_2^{-1}y=M-1{-1}b,x=M_2{-1}y$
	\end{enumerate}
	只讨论第三种技术：$A=A^T>0$\\
	}
	\frame{
	要求$M=M_1M_2=M^T>0$\\
	$M_1=M_2=m^{\frac{1}{2}}=C=C^T$\\
	$\Rightarrow C^{-1}AC^{-1}y=C{-1}b$\\
	据第一章中的定理1.2可知$C^{-1}AC{-1}$对称正定矩阵！\\
	希望：
	\begin{enumerate}
		\item $k(C^{-1}AC^{-1})<k(A)$
		\item 不显示形式$C^{-1}AC^{-1}$，因代价可能很大
		\item $M=C^2$比A“简单”，即解$Mz=r$比$Ax=b$要容易,即很快地高精度计算出z。对$C^{-1}AC^{-1}\hat{x}=C^{-1}b$应用CG
	\end{enumerate}
	CG算法：\\
	1)选取$\hat{X}_0 \in R^n$，计算$\hat{r}_0=\hat{b}-\hat{A}\hat{x}_0,\hat{p}_1=\hat{r}_0$\\
	对k=1,2,$\cdots$直到$||\hat{r}_k|| \le \hat{\epsilon}$\\
	$\hat{\alpha}_k = \frac { \hat{r}_{k-1}^T\hat{r}_{k-1}}{\hat{p}_k^T\hat{A}\hat{p}_k}$\\
	$\hat{x}_k = \hat{x}_{k-1} - \hat{\alpha}_k\hat{p}_k$\\
	$\hat{r}_k = \hat{r}_{k-1} - \hat{\alpha}_k\hat{A}\hat{p}_k$\\
	$\hat{\beta}_{k+1} = \frac{ \hat{r}_k^T\hat{r}_k}{\hat{r}_{k-1}^T\hat{r}_{k-1}}$\\
	$\hat{p}_{k+1} = \hat{r}_k + \hat{\beta}_{k+1}\hat{p}_k$\\
	end\\
	}
	\frame{
	算法中的$\hat{A}=C^{-1}AC^{-1}$要显式形式，如何避免？\\
	定义$\hat{x}_0=C_{x_0},\hat{r}_0=C^{-1}_{r_0}$\\
	$\hat{p}_1 = C^{-1}_{r_0} = C^{-1}_{p_1}$\\
	$\hat{x}_k = C_{x_k},\hat{r}_k = C^{-1}_{r_k}$\\
	$\hat{p}_0 = C_{p_0}, \hat{\alpha}_k = {\alpha}_k, \hat{\beta}_{k+1}={\beta}_{k+1}$\\
	则得到实用的PCG算法：\\
	1)选择$x_0 \in R^n, r_0 = b - Ax_0, p_1 = r_0$，解$Mz_0 = r_0$\\
	2)对$k=1,2,\cdots$,直到$||r_k|| \le \epsilon$\\
	${\alpha}_k = \frac{r_{k-1}^Tz-{k-1}}{p_k^TAp_k}$\\
	$x_k = x_{k-1} + {\alpha}_kp_k$\\
	$r_k = r_{k-1} - {\alpha}_kp_k$\\
	解$Mz_k = r_k$\\
	${\beta}_{k+1} = \frac{r_k^Tz_k}{r_{k-1}^Tz_{k-1}}$\\
	$p_{k+1} = z_k{\beta}_{k+1}p_k$\\
	end\\
	注：若M=I，PCG化为CG\\
	$K(C^{-1}AC^{-1})<k(A)$\\
	Mz=r要比Ax=b容易求解得多。希望1)和3)是矛盾的。\\
	}
	\frame{
	当$M=I,z_k=r_k$当M=A则CG一步即收敛，但$Mz=r \Leftrightarrow Ax=b$\\
	对$A=A^T>0$讨论M的选择。\\
	$Ax=b \Leftrightarrow x=Bx+f$\\
	构造迭代法\\
	$x_{k+1} = Bx_k + f, k=0,1,\cdots$\\
	如果$\rho(B)$(B的谱半径)($\rho(B)=max_{1\le i \le n}|\lambda_i(B)|$)小于1,则$\lim_{k \rightarrow \infty}x_k=x^*$\\
	$\rho(B)<1 \Leftrightarrow lim_{k \rightarrow \infty}x_k=x^*$\\
	且$\rho(B)$越小，则收敛一般越快。\\
	$\Rightarrow$B越趋于0,则收敛一般越快\\
	分裂A为$A=M-N\Rightarrow I - M^{-1}A = M^{-1}N$\\
	由(M-N)x = b即可得迭代法\\
	$x_{k+1}=M^{-1}Nx_k + M^{-1}b = Bx_k + f, k=0,1,\ldots$\\
	$m^{-1}N \approx 0 \Leftrightarrow I - M^{-1}n = M^{-1}A \approx I \Leftrightarrow M \approx A$\\
	具体的取$M=D=diag(a_{11},a_{22},\ldots,a_{nn})>0, N = L + L^T$\\
	L:A的严格下三角部分，（变号）得到Jacobi迭代法$M=D=D^{\frac{1}{2}}D^{\frac{1}{2}}$\\
	取$C=D^{\frac{1}{2}}$得到用方法预处理CG的算法。\\
	取$M = D - L, N = L^T$得到Gauss-Seidel(G-S)方法.\\
	}
	\frame{
	$B = M^{-1}N = (D-L)^{-1}L^T$\\
	当$A=A^T>0$，M和B都不对称，$x_{k+1}=Bx_k + f$,依次计算$x_{k+1,1},\ldots,x_{k+1,n}$\\
	使用一次以后，现在反序计算$x_{k+1,n},\ldots,x_{k+1,1}$。合并得到一个新的迭代法，称为对称SG-S。此时$M=(D-L)^{-T}L(D-L)^{-1}L^T=M6T>0$。记$M=CC^T$.对$C^{-1}AC^{-T}$，可类似推出PCG。另有SSOR(w)\\
	第二类预处理技术：\\
	$A=LL^T$。（cholesky分解）\\
	注意：A大型稀疏\\
	对如此的A进行$LL^T$分解，代价一般也是$\frac{1}{3n^3}$,L:满阵\\
	设想（不完全的分解）：要求L保持给定的稀疏结构。如和A的结构相同，得$A=\hat{L}\hat{L}^T+E$\\
	不完全的cholesky分解.\\
	$ILL^T$分解算法：\\
	$\tau_{11}=a_{11}^{\frac{1}{2}}$\\
	对$j=1,2,\ldots,n \tau_{jj}=(a_{jj}-\sum_{j=1}^{k-1}\tau_{jk}62)^{\frac{1}{2}}$\\
	}
	\frame{
	注：分解可能不存在！有多种变形，效果有差别。
	对一般的Ax=b常用左，右预处理\\
	$M^{-1}Ax = M^{-1}b$\\
	Jacob: M=D\\
	G-S:令$A=D-L-U,M=(D-L)^{-1}U$\\
	SOR:$M=(D-\omega L)^{-1}((p-\omega)I=\omega U)$\\
	不完全：LU(ILU):A=LU + E, M=LU\\
	}
	\frame{
	\frametitle{解对称不定Ax=b的Lanczos方法}
	}
\end{CJK*}
\end{document}
